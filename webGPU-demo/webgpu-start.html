<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <canvas id="gpuCanvas" width="800" height="500"></canvas>
</body>
<script>
    const init = async () => {
        if (!navigator.gpu) {
            throw Error("WebGPU not supported.");
        }

        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
            throw Error("Couldn't request WebGPU adapter.");
        }

        const device = await adapter.requestDevice();

        const shaders = `
        struct VertexOut {
            @builtin(position) position : vec4f,
            @location(0) color : vec4f
        }

        @vertex
        fn vertex_main(@location(0) position: vec4f,
            @location(1) color: vec4f) -> VertexOut
        {
            var output : VertexOut;
            output.position = position;
            output.color = color;
            return output;
        }

        @fragment
        fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
        {
            return fragData.color;
        }
    `;
        const shaderModule = device.createShaderModule({
            code: shaders,
        });

        const canvas = document.querySelector("#gpuCanvas");
        const context = canvas.getContext("webgpu");

        context.configure({
            device: device,
            format: navigator.gpu.getPreferredCanvasFormat(),
            alphaMode: "premultiplied",
        });

        const vertices = new Float32Array([
            0.0, 0.6, 0, 1,   1, 1, 0, 0.8,
            -0.5,-0.6, 0, 1,  0, 1, 1, 0.8,
            0.5,-0.6, 0, 1,   1, 0, 1, 0.8,
        ]);

        const vertexBuffer = device.createBuffer({
            size: vertices.byteLength, // make it big enough to store vertices in
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });

        device.queue.writeBuffer(vertexBuffer, 0, vertices, 0, vertices.length);

        const vertexBuffers = [
            {
                attributes: [
                    {
                        shaderLocation: 0, // 位置
                        offset: 0,
                        format: "float32x4",
                    },
                    {
                        shaderLocation: 1, // 颜色
                        offset: 16,
                        format: "float32x4",
                    },
                ],
                arrayStride: 32,
                stepMode: "vertex",
            },
        ];

        const pipelineDescriptor = {
            vertex: {
                module: shaderModule,
                entryPoint: "vertex_main",
                buffers: vertexBuffers,
            },
            fragment: {
                module: shaderModule,
                entryPoint: "fragment_main",
                targets: [
                    {
                        format: navigator.gpu.getPreferredCanvasFormat(),
                    },
                ],
            },
            primitive: {
                topology: "triangle-list",
            },
            layout: "auto",
        };

        const renderPipeline = device.createRenderPipeline(pipelineDescriptor);

        const commandEncoder = device.createCommandEncoder();


        const clearColor = { r: 0.5, g: 0.0, b: 0.5, a: 1.0 };

        const renderPassDescriptor = {
            colorAttachments: [
                {
                    clearValue: clearColor,
                    loadOp: "clear",
                    storeOp: "store",
                    view: context.getCurrentTexture().createView(),
                },
            ],
        };

        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);


        passEncoder.setPipeline(renderPipeline);
        passEncoder.setVertexBuffer(0, vertexBuffer);
        passEncoder.draw(3);

        passEncoder.end();

        device.queue.submit([commandEncoder.finish()]);
    }

    init();

</script>

</html>